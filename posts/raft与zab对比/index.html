<!doctype html><html lang=zh><head><title>Raft与ZAB对比</title>
<meta charset=utf-8><meta name=X-UA-Compatible content="IE=edge"><meta name=google-site-verification content><meta content="width=device-width,initial-scale=1,maximum-scale=5,user-scalable=5" name=viewport><meta content="telephone=no" name=format-detection><meta name=description content="Raft与ZAB对比"><meta name=renderer content="webkit"><meta name=theme-color content="#ffffff"><meta property="og:url" content="https://ngtrio.com/posts/raft%E4%B8%8Ezab%E5%AF%B9%E6%AF%94/"><meta property="og:site_name" content="星河鹭起"><meta property="og:title" content="Raft与ZAB对比"><meta property="og:description" content="Raft与ZAB对比"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-08-13T08:29:23+08:00"><meta property="article:modified_time" content="2021-08-13T08:29:23+08:00"><meta property="article:tag" content="分布式"><meta name=twitter:card content="summary"><meta name=twitter:title content="Raft与ZAB对比"><meta name=twitter:description content="Raft与ZAB对比"><link rel=icon href=https://ngtrio.com/favicon.ico><script src=/js/toc.js></script><link type=text/css rel=stylesheet href=/vendor/css/bootstrap.min.css><link rel=stylesheet href=/scss/dark-mode.min.ec0e925a0ec4c58d0a683b70aca65073d4b33dfe3536a142e742d89cb7404782.css integrity="sha256-7A6SWg7ExY0KaDtwrKZQc9SzPf41NqFC50LYnLdAR4I=" media=screen><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Material+Icons"><link type=text/css rel=stylesheet href=/vendor/fontawesome/css/all.min.css></head><body><div id=app><div class=single-column-drawer-container id=drawer v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }"><div class=drawer-content><div class=drawer-menu><a class="a-block drawer-menu-item active" href=/posts>归档 Archive
</a><a class="a-block drawer-menu-item false" href=/categories>分类 Categories
</a><a class="a-block drawer-menu-item false" href=/tags>标签 Tags</a><div class="a-block drawer-menu-item"><a class=nav-link-icon href=https://github.com/ngtrio target=_blank><i title=Github class="fab fa-github"></i></a>
<a class=nav-link-icon href=https://x.com/realngtrio target=_blank><i title=X class="fab fa-x-twitter"></i></a>
<a class=nav-link-icon href=mailto:ngtrio@gmail.com target=_blank><i title="Email to me!" class="fa fa-envelope"></i></a>
<a href=/index.xml target=_blank><i title=Feed class="fas fa-rss"></i></a></div><div class=toc><div class=toc-content><center>- 目录 -</center><ul><ul><li><a href=#zab class=nav-zab>ZAB</a></li><ul><li><a href=#zab%e8%8a%82%e7%82%b9%e7%8a%b6%e6%80%81 class=nav-zab节点状态>ZAB节点状态：</a></li><li><a href=#%e4%b8%93%e6%9c%89%e5%90%8d%e8%af%8d class=nav-专有名词>专有名词</a></li><li><a href=#%e7%90%86%e8%ae%ba%e5%ae%9e%e7%8e%b0%e7%9a%84%e5%9b%9b%e4%b8%aa%e9%98%b6%e6%ae%b5 class=nav-理论实现的四个阶段>理论实现的四个阶段</a></li><li><a href=#zookeeper%e7%9a%84%e5%ae%9e%e7%8e%b0 class=nav-zookeeper的实现>Zookeeper的实现</a></li></ul><li><a href=#raft class=nav-raft>Raft</a></li><ul><li><a href=#raft%e8%8a%82%e7%82%b9%e7%8a%b6%e6%80%81 class=nav-raft节点状态>Raft节点状态：</a></li><li><a href=#%e4%b8%a4%e8%80%85%e4%b8%8d%e5%90%8c%e7%82%b9 class=nav-两者不同点>两者不同点</a></li></ul></div></div></div></div></div><transition name=fade><div id=drawer-mask v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if=isDrawerOpen v-on:click=toggleDrawer></div></transition><nav id=navBar class="navbar sticky-top navbar-light single-column-nav-container"><div id=navBackground class=nav-background></div><div class="container container-narrow nav-content"><button id=nav_dropdown_btn class=nav-dropdown-toggle type=button v-on:click=toggleDrawer>
<i class=material-icons>menu
</i></button>
<a id=navTitle class=navbar-brand href=https://ngtrio.com/>星河鹭起
</a><button type=button class=nav-darkmode-toggle id=darkModeToggleButton2>
<i class=material-icons id=darkModeToggleIcon2>dark_mode</i></button></div></nav><div class=single-column-header-container id=pageHead v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }"><a href=https://ngtrio.com/><div class=single-column-header-title>星河鹭起</div></a></div><div id=content><div id=streamContainer class=stream-container><div class="post-list-container post-list-container-shadow"><div class=post><div class=post-head-wrapper-text-only><div class=post-title>Raft与ZAB对比<div class=post-subtitle>Raft与ZAB对比</div><div class=post-meta><time itemprop=datePublished>2021-08-13 08:29
</time><i class=material-icons>folder</i>
<a href=/categories/%E5%AD%A6%E4%B9%A0>学习</a>
&nbsp;
<i class=material-icons>label</i>
<a href=/tags/%E5%88%86%E5%B8%83%E5%BC%8F>分布式</a>
&nbsp;
<i class=material-icons>schedule</i>
13 min
21 s.</div></div></div><div class=post-body-wrapper><div class=post-body v-pre><h2 id=zab><strong>ZAB</strong></h2><h3 id=zab节点状态><strong>ZAB节点状态：</strong></h3><ol><li>LOOKING</li><li>FOLLOWING</li><li>LEADING</li><li>OBSERVING</li></ol><h3 id=专有名词><strong>专有名词</strong></h3><ol><li>electionEpoch：选举的逻辑时钟</li><li>peerEpoch：每次leader选举完成后会选出一个peerEpoch</li><li>zxid：每个proposal的唯一id，高32位为peerEpoch低32位为counter</li><li>lastProcessedZxid：最后一次commit的zxid</li></ol><h3 id=理论实现的四个阶段><strong>理论实现的四个阶段</strong></h3><p><strong>Phase 0. Leader election</strong></p><p>所有节点最开始都是LOOKING。只要有一个节点得到超半数节点的票数，它就可以当选准 leader。只有到达 Phase 3 准 leader 才会成为真正的 leader。这一阶段的目的是就是为了选出一个准 leader，然后进入下一个阶段。</p><p>协议并没有规定详细的选举算法。</p><p><strong>Phase 1. Discovery</strong></p><p>这个阶段有两个工作</p><ol><li>获取所有follower的lastZxid确定当前集群中有哪个节点拥有最新数据</li><li>从所有follower的currentEpoch中选出一个最大的然后自增1得到peerEpoch，并发给所有follower，follower会将自己的acceptEpoch设置为peerEpoch，拒绝一切小于该epoch的请求</li></ol><p><strong>Phase 2. Synchronization</strong></p><p>这个阶段就是根据Discovery阶段找到的最新数据节点，leader会与其同步。</p><p><strong>这里发生了follower到leader的数据同步，这是和zookeeper的实现还有raft的实现是不一样的</strong></p><p>同步完成后，会向所有follower同步数据，只有当quorum的follower都完成了数据同步后，其当选为新的leader。</p><p><strong>Phase 3 . Broadcast</strong></p><p>到了这个阶段， leader才能对外提供服务，可以进行消息广播。数据同步的过程类似一个2PC，Leader将client发过来的请求生成一个事务proposal，然后发送给Follower，多数Follower应答之后，Leader再发送Commit给全部的Follower让其进行提交。</p><h3 id=zookeeper的实现><strong>Zookeeper的实现</strong></h3><p><strong>Phase 0. Fast Leader Election</strong></p><p>这个阶段相当于是理论实现中的Phase 0，Phase 1的整合。每个节点不断更新自己的票箱，最终能够找到lastZxid最大的节点，并将其推选为leader。</p><p>这样的实现也避免了sync的时候需要从follower向leader同步数据。</p><p>成为leader的条件</p><ul><li>epoch最大</li><li>zxid最大</li><li>server id最大</li></ul><p>节点在选举开始都默认投票给自己，当接收其他节点的选票时，会根据上面的条件更改自己的选票并重新发送选票给其他节点，当有一个节点的得票超过半数，该节点会设置自己的状态为 leading，其他节点会设置自己的状态为 following。</p><p><strong>Phase 1. Recovery</strong></p><p>这个阶段所有的follower都会发送自己的lastZxid到leader。</p><p>Leader会根据follower的lastZxid和自己的lastZxid进行比较，做出如下三种可能的同步策略：</p><ol><li>SNAP：如果follower数据太老，已经小于minCommitLog则采取快照同步</li><li>DIFF：如果follower的lastZxid 处于minCommitLog和maxCommitLog之间，则采取增量同步F.lastZxid-L.lastZxid之间的数据</li><li>TRUNC：当F.lastZxid比L.lastZxid大时，Leader会让follower删除所有对于的数据</li></ol><p><strong>Phase 2. Broadcast</strong></p><p>同理论实现</p><h2 id=raft><strong>Raft</strong></h2><h3 id=raft节点状态><strong>Raft节点状态：</strong></h3><ol><li>FOLLOWER</li><li>CANDIDATE</li><li>LEADER</li></ol><p><strong>触发Leader选举时机</strong></p><ol><li>当整个集群初始化的时候，所有节点都是Follower，此时等到超时的节点会转变为Candidate发起RequestVoteRPC发起选举</li><li>当leader down掉后，由于不再有AppendEntriesRPC来维持心跳，follower也会发生超时，开始选举</li></ol><p><strong>Leader Election</strong></p><p>当Follower/Candidate发生超时</p><ol><li>首先将自己的Term自增1</li><li>然后投票给自己</li><li>会向集群中的所有节点发送RequestVoteRPC</li></ol><p>当收到majority的选票后，自己会转变为Leader，此时会开始向所有其他节点发送AppendEntriesRPC。</p><p>Follower投票的条件：</p><ol><li>Candidate的Term比自身的Term大</li><li>如果Term一样，那么就需要candidate的last log index比自己的大</li></ol><p>通过上述条件选出来的leader能够保证会拥有所有已经提交的entry</p><p><strong>Log Replication</strong></p><p>选举完成后：</p><ol><li>当一个节点成为leader后会初始化两个数组<ol><li>nextIndex，记录所有follower的下一个日志index，初始值为leader的last log index</li><li>matchIndex，记录所有follower已经确定完成同步的日志index</li></ol></li><li>然后通过AppendEntriesRPC完成数据同步：<ol><li>prevLogIndex：记录上一条日志index</li><li>prevLogTerm：记录上一条日志Term</li></ol></li><li>只要follower发现没有一个下标为prevLogIndex并且term为prevLogTerm的entry都会返回false，leader便会把其对应的nextIndex减一，一直重复这个过程直到两者match，并更新matchIndex</li><li>后续AppendEntriesRPC便会逐渐将Follower的日志补齐</li></ol><p>处理客户端命令：</p><ol><li>Leader处理读，每个entry只有append到大多数节点的时候，主节点才视为commit，并且更新commitIdex，随后这个commitIndex会被AppendEntriesRPC逐渐同步到Follower</li><li>所有节点，只要发现commitIndex>lastApplied都会将entry提交到状态机</li></ol><p><strong>Log Compaction</strong></p><p>由于内存是有限的，所有的节点都会定期对缓存的log进行compact生成snapshot，对于远远落后的follower，主节点会发送InstallSnapshotRPC给follower,这个过程是分成一个个chunk来完成的</p><h3 id=两者不同点><strong>两者不同点</strong></h3><ol><li>触发选举方式不同<ul><li>raft follower超时+prevote避免term无限递增</li><li>zab follower超时+leader发现大多数follower超时</li></ul></li><li>选举机制不同<ul><li>raft每个term只会投一票，存在split vote可能性</li><li>zab每个epoch会不断更新选票，时间理论上相对Raft要花费的多。</li></ul></li><li>日志同步机制不同，并且对未提交日志的处理方式不同<ul><li>Raft中leader是根据AppendEntriesRPC的nextIndex，prevLogIndex，prevLogTerm来跟踪follower的同步情况，并实现逐步的同步，期间有个election restriction，限制term只能commit属于term的entry，旧term的entry只能被当前term的commit给附带commit。所以raft中未提交的日志可能提交也可能会被覆盖</li><li>ZAB在选主后，有一个Recovery阶段，根据每个节点的lastZxid来判断日志的取舍，在leader上所有没有commit的日志都会提交。</li></ul></li><li>残留日志处理<ul><li>Raft：对于之前term的过半或未过半复制的日志采取的是保守的策略，全部判定为未提交，只有当当前term的日志过半了，才会顺便将之前term的日志进行提交</li><li>ZooKeeper：采取激进的策略，对于所有过半还是未过半的日志都判定为提交，都将其应用到状态机中</li></ul></li></ol><hr width=100% id=EOF><p style=color:#777>最后修改于 2021-08-13</p></div></div><nav class=post-pagination><a class=newer-posts href=/posts/ddia/>下回<br>读DDIA-数据复制
</a><a class=older-posts href=/posts/scala%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E7%9A%84%E7%90%86%E8%A7%A3/>上回<br>Scala隐式转换的理解</a></nav><div class=post-comment-wrapper></div></div></div></div></div><div id=sideContainer class=side-container><a class="a-block nav-head false" href=https://ngtrio.com/><div class=nav-title>星河鹭起</div></a><div class=nav-link-list><a class="a-block nav-link-item active" href=/posts>归档 Archive
</a><a class="a-block nav-link-item false" href=/categories>分类 Categories
</a><a class="a-block nav-link-item false" href=/tags>标签 Tags</a><div class="a-block nav-link-item"><a class=nav-link-icon href=https://github.com/ngtrio target=_blank><i title=Github class="fab fa-github"></i></a>
<a class=nav-link-icon href=https://x.com/realngtrio target=_blank><i title=X class="fab fa-x-twitter"></i></a>
<a class=nav-link-icon href=mailto:ngtrio@gmail.com target=_blank><i title="Email to me!" class="fa fa-envelope"></i></a>
<a href=/index.xml target=_blank><i title=Feed class="fas fa-rss"></i></a></div></div><div class=nav-footer>&copy;
ngtrio. 本站遵循 CC-BY-NC 4.0 协议</div></div><div id=extraContainer class=extra-container><div class=toc-wrapper><div class=toc><div class=toc-content><center>- 目录 -</center><ul><ul><li><a href=#zab class=nav-zab>ZAB</a></li><ul><li><a href=#zab%e8%8a%82%e7%82%b9%e7%8a%b6%e6%80%81 class=nav-zab节点状态>ZAB节点状态：</a></li><li><a href=#%e4%b8%93%e6%9c%89%e5%90%8d%e8%af%8d class=nav-专有名词>专有名词</a></li><li><a href=#%e7%90%86%e8%ae%ba%e5%ae%9e%e7%8e%b0%e7%9a%84%e5%9b%9b%e4%b8%aa%e9%98%b6%e6%ae%b5 class=nav-理论实现的四个阶段>理论实现的四个阶段</a></li><li><a href=#zookeeper%e7%9a%84%e5%ae%9e%e7%8e%b0 class=nav-zookeeper的实现>Zookeeper的实现</a></li></ul><li><a href=#raft class=nav-raft>Raft</a></li><ul><li><a href=#raft%e8%8a%82%e7%82%b9%e7%8a%b6%e6%80%81 class=nav-raft节点状态>Raft节点状态：</a></li><li><a href=#%e4%b8%a4%e8%80%85%e4%b8%8d%e5%90%8c%e7%82%b9 class=nav-两者不同点>两者不同点</a></li></ul></div></div></div><div class=pagination><a id=globalBackToTop class="pagination-action animated-visibility" href=#top :class="{ invisible: scrollY == 0 }"><i class="material-icons pagination-action-icon">keyboard_arrow_up
</i></a><a type=button class=pagination-action id=darkModeToggleButton><span class="material-icons pagination-action-icon" id=darkModeToggleIcon>dark_mode</span></a></div></div><div id=single-column-footer>&copy;
ngtrio. 本站遵循 CC-BY-NC 4.0 协议</div></div><script src=/js/journal.js></script></body></html>