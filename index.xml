<?xml-stylesheet href="/rss.xsl" type="text/xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>星河鹭起</title><link>https://ngtrio.com/</link><description>Recent content on 星河鹭起</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>ngtrio. 本站遵循 CC-BY-NC 4.0 协议</copyright><lastBuildDate>Tue, 01 Oct 2024 18:48:19 +0800</lastBuildDate><atom:link href="https://ngtrio.com/index.xml" rel="self" type="application/rss+xml"/><item><title>正确的理财</title><link>https://ngtrio.com/posts/%E6%AD%A3%E7%A1%AE%E7%9A%84%E7%90%86%E8%B4%A2/</link><pubDate>Tue, 01 Oct 2024 18:48:19 +0800</pubDate><guid>https://ngtrio.com/posts/%E6%AD%A3%E7%A1%AE%E7%9A%84%E7%90%86%E8%B4%A2/</guid><description>星河鹭起 https://ngtrio.com/posts/%E6%AD%A3%E7%A1%AE%E7%9A%84%E7%90%86%E8%B4%A2/ -&lt;p>24年国庆，正好是工作四年出头，利用空闲时间回顾了这四年以来个人的开销和积蓄，花的钱都还算有价值，该攒的也有认真在攒，整体比较健康。&lt;/p>
&lt;p>不过在近期A股大涨的背景下，理财这方面实在是相形见绌。从19年开始买入基金，再到今年开通证券账户，虽前前后后有五年之久，但从没花精力去培养有关思维、学习理论基础，每一次买入和卖出实际都充满赌的成分，花了时间也花了精力。类似状态的人在周围其实有很多，20年左右毕业的应届，因为工作给予了人生第一笔可以自主支配的钱，加上伴随上演的基金潮，都纷纷带着刚进社会的勇气buff就下场了。&lt;/p>
&lt;p>加上货币逐渐数字化，纸币给人的分量感渐渐缺失，风险意识其实越来越淡薄，账户上一个简单的五位数字&lt;code>10000&lt;/code>，拿在手中实际上是&lt;code>100&lt;/code>张红色的百元大钞。回想当年地铁上不经意看到旁边手机十万余额的基金账户，心里还会默默佩服这位陌生人的胆识，现在再去想想倒也觉得寻常，这种在实际投资水平没有进步的情况下，逐步对风险变得麻木的心理变化，其实是很恐怖的。&lt;/p>
&lt;p>不过不能否认自己用适当风险去博取额外收益的意识，但得明白它有认知门槛，赚认知外的钱很难，但可以花时间去构建认知，许多人推荐先从《穷爸爸富爸爸》《小狗钱钱》去构建理财观念，那么就从这两本书开始吧。&lt;/p>
- https://ngtrio.com/posts/%E6%AD%A3%E7%A1%AE%E7%9A%84%E7%90%86%E8%B4%A2/ - ngtrio. 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>Go Generics</title><link>https://ngtrio.com/posts/go-genric/</link><pubDate>Sun, 17 Apr 2022 23:09:41 +0800</pubDate><guid>https://ngtrio.com/posts/go-genric/</guid><description>星河鹭起 https://ngtrio.com/posts/go-genric/ -&lt;p>&lt;img src="images/2022-04-17-15-22-16.png" alt="">&lt;/p>
&lt;ul>
&lt;li>Generics&lt;/li>
&lt;li>Fuzzing&lt;/li>
&lt;li>Workspaces&lt;/li>
&lt;li>20% Performance Improvements&lt;/li>
&lt;/ul>
&lt;p>本文是对Go1.18的第一个特性：泛型（Generics）做的一些体验总结。&lt;/p>
&lt;h2 id="从常见的场景说起">从常见的场景说起&lt;/h2>
&lt;h3 id="对指针类型进行解引用">对指针类型进行解引用&lt;/h3>
&lt;p>一般我们会像下面这样对不同的类型分别实现对应的解引用函数（不使用反射的情况下）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">func&lt;/span> &lt;span style="color:#008b45">PtrToString&lt;/span>(strPtr *&lt;span style="color:#00688b;font-weight:bold">string&lt;/span>) &lt;span style="color:#00688b;font-weight:bold">string&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">if&lt;/span> strPtr == &lt;span style="color:#8b008b;font-weight:bold">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">return&lt;/span> &lt;span style="color:#cd5555">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#d6d6c6">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">return&lt;/span> *strPtr
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">func&lt;/span> &lt;span style="color:#008b45">PtrToInt&lt;/span>(intPtr *&lt;span style="color:#00688b;font-weight:bold">int&lt;/span>) &lt;span style="color:#00688b;font-weight:bold">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">if&lt;/span> intPtr == &lt;span style="color:#8b008b;font-weight:bold">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">return&lt;/span> &lt;span style="color:#b452cd">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">return&lt;/span> *intPtr
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">func&lt;/span> &lt;span style="color:#008b45">PtrToBool&lt;/span>(boolPtr *&lt;span style="color:#00688b;font-weight:bold">bool&lt;/span>) &lt;span style="color:#00688b;font-weight:bold">bool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">if&lt;/span> boolPtr == &lt;span style="color:#8b008b;font-weight:bold">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">return&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">return&lt;/span> *boolPtr
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">// ...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>每新增一个类型我们就需要针对这个类型实现一段类似重复的代码，但这些函数的唯一不同点，&lt;strong>实际上只有函数参数的类型和函数响应值的类型不同&lt;/strong>。&lt;/p>
&lt;p>而 &lt;strong>泛型(Generics)&lt;/strong> 就是给变量的类型也引入“形参&amp;amp;实参”的概念。我们定义函数的时候可以给参数类型定义“类型形参”，在调用函数的时候，我们可以给函数传入类型的实参。如果我们使用泛型，上述的代码实现可以转变为下面这样：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">// 定义解引用函数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">func&lt;/span> FromPtr[T &lt;span style="color:#00688b;font-weight:bold">any&lt;/span>](anyPtr *T) T {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">var&lt;/span> zero T
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">if&lt;/span> anyPtr == &lt;span style="color:#8b008b;font-weight:bold">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#d6d6c6">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">return&lt;/span> zero
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">return&lt;/span> *anyPtr
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对于不同的类型，我们都只需要调用这一个&lt;code>泛型函数&lt;/code>即可。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">// 调用解引用函数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">func&lt;/span> &lt;span style="color:#008b45">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">var&lt;/span> intPtr *&lt;span style="color:#00688b;font-weight:bold">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">var&lt;/span> strPtr *&lt;span style="color:#00688b;font-weight:bold">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#d6d6c6">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">var&lt;/span> boolPtr *&lt;span style="color:#00688b;font-weight:bold">bool&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a := &lt;span style="color:#b452cd">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> b := &lt;span style="color:#cd5555">&amp;#34;str&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c := &lt;span style="color:#8b008b;font-weight:bold">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#228b22">// 类型实参自动推断，所以不需要我们像下面这样手动传入了&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#228b22">// fmt.Println(FromPtr[int](intPtr))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#008b45">Println&lt;/span>(&lt;span style="color:#008b45">FromPtr&lt;/span>(intPtr)) &lt;span style="color:#228b22">// 0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#008b45">Println&lt;/span>(&lt;span style="color:#008b45">FromPtr&lt;/span>(strPtr)) &lt;span style="color:#228b22">// &amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#008b45">Println&lt;/span>(&lt;span style="color:#008b45">FromPtr&lt;/span>(boolPtr)) &lt;span style="color:#228b22">// false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#008b45">Println&lt;/span>(&lt;span style="color:#008b45">FromPtr&lt;/span>(&amp;amp;a)) &lt;span style="color:#228b22">// 1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#008b45">Println&lt;/span>(&lt;span style="color:#008b45">FromPtr&lt;/span>(&amp;amp;b)) &lt;span style="color:#228b22">// str&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#008b45">Println&lt;/span>(&lt;span style="color:#008b45">FromPtr&lt;/span>(&amp;amp;c)) &lt;span style="color:#228b22">// true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="自定义容器">自定义容器&lt;/h3>
&lt;p>假设我们想定义一个能够做元素累加的容器&lt;br>
以往我们需要为每个基础类型分别定义一个容器，并相应实现对应的累加方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> IntSlice []&lt;span style="color:#00688b;font-weight:bold">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> StrSlice []&lt;span style="color:#00688b;font-weight:bold">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">func&lt;/span>(s IntSlice) &lt;span style="color:#008b45">AddAll&lt;/span>() &lt;span style="color:#00688b;font-weight:bold">int&lt;/span> {&lt;span style="color:#228b22">/*省略*/&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#d6d6c6">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">func&lt;/span>(s StrSlice) &lt;span style="color:#008b45">AddAll&lt;/span>() &lt;span style="color:#00688b;font-weight:bold">string&lt;/span> {&lt;span style="color:#228b22">/*省略*/&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当有了泛型特性之后，我们只需要定义一个&lt;code>泛型类型&lt;/code>, 然后实现累加的&lt;code>泛型方法&lt;/code>即可:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> AnySlice[T &lt;span style="color:#00688b;font-weight:bold">int&lt;/span> | &lt;span style="color:#00688b;font-weight:bold">string&lt;/span>] []T
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">func&lt;/span> (s AnySlice[T]) &lt;span style="color:#008b45">AddAll&lt;/span>() T {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">var&lt;/span> ret T
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">for&lt;/span> _, elem := &lt;span style="color:#8b008b;font-weight:bold">range&lt;/span> s {
&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#d6d6c6">&lt;span> ret += elem
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">return&lt;/span> ret
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以这样使用定义好的&lt;code>泛型类型&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>intSlice := AnySlice[&lt;span style="color:#00688b;font-weight:bold">int&lt;/span>]{&lt;span style="color:#b452cd">1&lt;/span>, &lt;span style="color:#b452cd">2&lt;/span>, &lt;span style="color:#b452cd">3&lt;/span>, &lt;span style="color:#b452cd">4&lt;/span>, &lt;span style="color:#b452cd">5&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>strSlice := AnySlice[&lt;span style="color:#00688b;font-weight:bold">string&lt;/span>]{&lt;span style="color:#cd5555">&amp;#34;str1&amp;#34;&lt;/span>, &lt;span style="color:#cd5555">&amp;#34;str2&amp;#34;&lt;/span>, &lt;span style="color:#cd5555">&amp;#34;str3&amp;#34;&lt;/span>, &lt;span style="color:#cd5555">&amp;#34;str4&amp;#34;&lt;/span>, &lt;span style="color:#cd5555">&amp;#34;str5&amp;#34;&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#008b45">Println&lt;/span>(intSlice.&lt;span style="color:#008b45">AddAll&lt;/span>()) &lt;span style="color:#228b22">// 15&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#d6d6c6">&lt;span>fmt.&lt;span style="color:#008b45">Println&lt;/span>(strSlice.&lt;span style="color:#008b45">AddAll&lt;/span>()) &lt;span style="color:#228b22">// str1str2str3str4str5&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="基本概念">基本概念&lt;/h2>
&lt;p>我们使用上面定义的泛型函数引入一些基本概念&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span> 类型参数列表 类型约束
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">func&lt;/span> FromPtr[T &lt;span style="color:#00688b;font-weight:bold">any&lt;/span>](anyPtr *T) T - 泛型函数
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a61717;background-color:#e3d2d2">\&lt;/span> /_/
&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#d6d6c6">&lt;span> &lt;span style="color:#a61717;background-color:#e3d2d2">\&lt;/span> 类型形参 /
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 类型实参
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>FromPtr[&lt;span style="color:#00688b;font-weight:bold">int&lt;/span>](intPtr) - 泛型函数调用
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 类型参数列表 类型约束
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | ------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> AnySlice[T &lt;span style="color:#00688b;font-weight:bold">int&lt;/span> | &lt;span style="color:#00688b;font-weight:bold">string&lt;/span>] []T - 泛型类型
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a61717;background-color:#e3d2d2">\&lt;/span> /
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a61717;background-color:#e3d2d2">\&lt;/span> 类型形参 /
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 泛型接收器
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">func&lt;/span> (s AnySlice[T]) &lt;span style="color:#008b45">AddAll&lt;/span>() T - 泛型方法
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 类型实参
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>AnySlice[&lt;span style="color:#00688b;font-weight:bold">int&lt;/span>]{&lt;span style="color:#b452cd">1&lt;/span>, &lt;span style="color:#b452cd">2&lt;/span>, &lt;span style="color:#b452cd">3&lt;/span>, &lt;span style="color:#b452cd">4&lt;/span>, &lt;span style="color:#b452cd">5&lt;/span>} - 泛型类型实例化
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Go泛型的大部分基本概念其实和其他拥有泛型特性的语言基本类似，就不再过多赘述，下面针对不太一样的类型约束做一些介绍。&lt;/p>
&lt;h2 id="类型约束type-constraint">类型约束(type constraint)&lt;/h2>
&lt;p>了解类型约束的机制，我们才能明白什么样的类型才能实例化我们定义的泛型。&lt;br>
Go语言本身的类型系统比较简单，不像Scala、Kotlin等语言，有诸如协变、逆变等概念，Go的类型是「不变的」，因此下面的代码会在编译期就报错&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> Container[T A] []T
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">func&lt;/span> &lt;span style="color:#008b45">Append&lt;/span>(c Container[&lt;span style="color:#00688b;font-weight:bold">any&lt;/span>]) Container[&lt;span style="color:#00688b;font-weight:bold">any&lt;/span>] {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">return&lt;/span> &lt;span style="color:#658b00">append&lt;/span>(c, &lt;span style="color:#cd5555">&amp;#34;abc&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#d6d6c6">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a := &lt;span style="color:#658b00">make&lt;/span>(Container[&lt;span style="color:#00688b;font-weight:bold">int&lt;/span>], &lt;span style="color:#b452cd">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008b45">Append&lt;/span>(a) &lt;span style="color:#228b22">// 编译期报错，cannot use a (variable of type Container[int]) as Container[any] value in argument to Append compilerIncompatibleAssign&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Go泛型的类型是通过「类型集」来约束的。下面类型形参后面的部分就是类型约束：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">func&lt;/span> FromPtr[T &lt;span style="color:#00688b;font-weight:bold">any&lt;/span>](anyPtr *T) T &lt;span style="color:#228b22">// T 约束为 any, 等同于接受所有类型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> AnySlice[T &lt;span style="color:#00688b;font-weight:bold">int&lt;/span> | &lt;span style="color:#00688b;font-weight:bold">string&lt;/span>] []T &lt;span style="color:#228b22">// T 只接受 int, string&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的例子中「any」是个类型集，包含了所有的类型。「int | string」也是个类型集，包含了int和string两个类型。&lt;/p>
&lt;p>另外为了使得代码更加容易维护，我们可以通过interface来定义类型集，比如下面这个interface代表所有int类型的类型集：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> Int &lt;span style="color:#8b008b;font-weight:bold">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b;font-weight:bold">int&lt;/span> | &lt;span style="color:#00688b;font-weight:bold">int8&lt;/span> | &lt;span style="color:#00688b;font-weight:bold">int16&lt;/span> | &lt;span style="color:#00688b;font-weight:bold">int32&lt;/span> | &lt;span style="color:#00688b;font-weight:bold">int64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#d6d6c6">&lt;span>&lt;span style="color:#228b22">// 然后利用Int来做约束&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> GType[T Int] []T
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的例子中，「Int」接口是int、int8、int16、int32、int64的一个类型集，那么这五个类型都可以去实例化泛型类型「GType」。&lt;/p>
&lt;p>实际上，Go的Specification中已经指明interface定义了一个类型集：&lt;code>An interface type defines a type set&lt;/code>&lt;/p>
&lt;p>我们知道Go的interface在之前都只能定义接口方法，本次引入泛型后还能定义一组类型。为了保证向前兼容，interface被分成了下面两种。&lt;/p>
&lt;h3 id="基础接口basic-interfaces">基础接口（Basic interfaces）&lt;/h3>
&lt;p>只包含方法的interface。&lt;br>
假设类型&lt;code>T&lt;/code>实现了基本接口&lt;code>I&lt;/code>中定义的全部方法，那么我们称类型&lt;code>T&lt;/code>实现了接口&lt;code>I&lt;/code>, 类型&lt;code>T&lt;/code>满足接口&lt;code>I&lt;/code>的类型约束。(有点类似于其他语言中的类型上界的味道)&lt;br>
举例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> Type[T Parent] []T &lt;span style="color:#228b22">// 泛型类型，类型约束为Parent&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> Parent &lt;span style="color:#8b008b;font-weight:bold">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008b45">Func&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#d6d6c6">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> Child &lt;span style="color:#8b008b;font-weight:bold">struct&lt;/span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">func&lt;/span> (c Child) &lt;span style="color:#008b45">Func&lt;/span>() {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> Child1 &lt;span style="color:#8b008b;font-weight:bold">struct&lt;/span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">var&lt;/span> t Type[Child] &lt;span style="color:#228b22">// ok, 因为Child实现了Parent&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">var&lt;/span> t1 Type[Child1] &lt;span style="color:#228b22">// wrong, Child1没有实现方法Func&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="一般接口general-interfaces">一般接口（General interfaces）&lt;/h3>
&lt;p>除了包含方法，还会包含&lt;code>t1|t2|…|tn&lt;/code>这种形式的类型定义的interface。&lt;br>
假设类型&lt;code>T&lt;/code>是接口&lt;code>I&lt;/code>定义的&lt;code>t1|t2|…|tn&lt;/code>中的一个，并且实现了接口&lt;code>I&lt;/code>的所有方法。那么我们称类型&lt;code>T&lt;/code>实现了接口&lt;code>I&lt;/code>, 类型&lt;code>T&lt;/code>满足接口&lt;code>I&lt;/code>的类型约束。&lt;br>
举例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> Type[T Parent] []T &lt;span style="color:#228b22">// 泛型类型，类型约束为Parent&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> Parent &lt;span style="color:#8b008b;font-weight:bold">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Child | Child1
&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#d6d6c6">&lt;span> &lt;span style="color:#008b45">Func&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> Child &lt;span style="color:#8b008b;font-weight:bold">struct&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">func&lt;/span> (c Child) &lt;span style="color:#008b45">Func&lt;/span>() {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> Child1 &lt;span style="color:#8b008b;font-weight:bold">struct&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> Child2 &lt;span style="color:#8b008b;font-weight:bold">struct&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">func&lt;/span> (c Child2) &lt;span style="color:#008b45">Func&lt;/span>() {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">var&lt;/span> t Type[Child] &lt;span style="color:#228b22">// ok, 因为Child实现了Parent&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">var&lt;/span> t1 Type[Child1] &lt;span style="color:#228b22">// wrong, Child1没有实现方法Func&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">var&lt;/span> t2 Type[Child2] &lt;span style="color:#228b22">// wrong, Child2实现了方法Func，但不是 Child | Child1 中的一员&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="类型并集">类型并集&lt;/h3>
&lt;p>一个接口中，每行的类型取并集&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> IntA &lt;span style="color:#8b008b;font-weight:bold">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b;font-weight:bold">int&lt;/span> | &lt;span style="color:#00688b;font-weight:bold">int8&lt;/span> | &lt;span style="color:#00688b;font-weight:bold">int16&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#d6d6c6">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> IntB &lt;span style="color:#8b008b;font-weight:bold">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b;font-weight:bold">int8&lt;/span> | &lt;span style="color:#00688b;font-weight:bold">int16&lt;/span> | &lt;span style="color:#00688b;font-weight:bold">int32&lt;/span> | &lt;span style="color:#00688b;font-weight:bold">int64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> IntC &lt;span style="color:#8b008b;font-weight:bold">interface&lt;/span> { &lt;span style="color:#228b22">// 等价于 int | int8 | int16 | int32 | int64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> IntA | IntB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="类型交集">类型交集&lt;/h3>
&lt;p>一个接口中行之间的类型定义将取交集&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> IntA &lt;span style="color:#8b008b;font-weight:bold">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b;font-weight:bold">int&lt;/span> | &lt;span style="color:#00688b;font-weight:bold">int8&lt;/span> | &lt;span style="color:#00688b;font-weight:bold">int16&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#d6d6c6">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> IntB &lt;span style="color:#8b008b;font-weight:bold">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b;font-weight:bold">int8&lt;/span> | &lt;span style="color:#00688b;font-weight:bold">int16&lt;/span> | &lt;span style="color:#00688b;font-weight:bold">int32&lt;/span> | &lt;span style="color:#00688b;font-weight:bold">int64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> IntC &lt;span style="color:#8b008b;font-weight:bold">interface&lt;/span> { &lt;span style="color:#228b22">// 等价于 int8 | int16&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> IntA
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> IntB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="底层类型约束">底层类型约束&lt;/h3>
&lt;p>Go新增了一个符号&lt;code>~&lt;/code>, 置于基础类型前的时候，这个类型集合将不止包含这个基础类型，还会包含所有底层类型为该基础类型的类型。&lt;br>
比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> Int &lt;span style="color:#8b008b;font-weight:bold">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ~&lt;span style="color:#00688b;font-weight:bold">int&lt;/span> | ~&lt;span style="color:#00688b;font-weight:bold">int8&lt;/span> | ~&lt;span style="color:#00688b;font-weight:bold">int16&lt;/span> | ~&lt;span style="color:#00688b;font-weight:bold">int32&lt;/span> | ~&lt;span style="color:#00688b;font-weight:bold">int64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#d6d6c6">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> IntType &lt;span style="color:#00688b;font-weight:bold">int&lt;/span> &lt;span style="color:#228b22">// IntType也满足Int接口定义的类型约束&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="后续">后续&lt;/h2>
&lt;ul>
&lt;li>泛型接口&lt;/li>
&lt;/ul>
- https://ngtrio.com/posts/go-genric/ - ngtrio. 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>OpenWRT跑Go定时任务</title><link>https://ngtrio.com/posts/openwrt%E8%B7%91go%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</link><pubDate>Sun, 23 Jan 2022 10:48:19 +0800</pubDate><guid>https://ngtrio.com/posts/openwrt%E8%B7%91go%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</guid><description>星河鹭起 https://ngtrio.com/posts/openwrt%E8%B7%91go%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/ -&lt;h2 id="背景">背景&lt;/h2>
&lt;p>因为前段时间为了做一个全局的🪜，于是把家里的路由器刷了一个OpenWRT，尽管路由器性能比较拉胯，但是架起了🪜后，还是有一定的闪存空间以及内存空间，最近想把这点空间也给利用上，&lt;del>路由器24h工作的电费得找补回来。&lt;/del> &lt;br>
想到之前学习Go的时候写了个简单的TG机器人，刚好最近想跑几个定时任务，于是决定把这个机器人搭建到路由器上。&lt;/p>
&lt;h2 id="交叉编译">交叉编译&lt;/h2>
&lt;p>因为路由器的CPU架构不一样，我自己本机编译的二进制自然是无法在路由器上跑起来的。所以需要进行交叉编译，这里看到我的路由器CPU架构是&lt;code>mips&lt;/code>&lt;/p>
&lt;pre tabindex="0">&lt;code>root@OpenWrt:~# uname -m
mips
&lt;/code>&lt;/pre>&lt;p>&lt;a href="https://go.dev/doc/install/source#environment">Go原生就支持交叉编译&lt;code>mips&lt;/code>指令集的二进制&lt;/a>，所以这一步就很简单了。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00688b">GOOS&lt;/span>=linux &lt;span style="color:#00688b">GOARCH&lt;/span>=mipsle &lt;span style="color:#00688b">GOMIPS&lt;/span>=softfloat go build
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="时区问题">时区问题&lt;/h2>
&lt;p>晚上定时任务写好，编译好，在路由器上跑起来后就睡觉去了，但是第二天早上九点多起床发现我的tg bot并没有收到cron为&lt;code>0 0 8 * * ?&lt;/code>的定时任务消息。&lt;br>
首先ssh到路由器，可以确定我的tgbot的进程并没有挂掉，查看日志也没有任何错误信息，但是发现日志的时间都是&lt;code>UTC&lt;/code>时间，这就意味着定时任务其实还没到触发的时间。&lt;br>
但是记得之前是在OpenWRT后台是设置过&lt;code>UTC+8&lt;/code>时区的，并且在路由器的shell执行&lt;code>date -R&lt;/code>也显示的是&lt;code>UTC+8&lt;/code>&lt;/p>
&lt;pre tabindex="0">&lt;code>root@OpenWrt:/etc# date -R
Sun, 23 Jan 2022 10:56:06 +0800
&lt;/code>&lt;/pre>&lt;p>而我也清楚记得Go的time.Format()默认就是采用的系统时区，这里Go没有读取到就有点奇怪了。&lt;br>
于是了解了下细节：&lt;/p>
&lt;ol>
&lt;li>OpenWRT在哪里设置了时区
&lt;ul>
&lt;li>/etc/TZ文件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Go从哪里获取系统时区
&lt;ul>
&lt;li>读取TZ环境变量&lt;/li>
&lt;li>读取/etc/localtime文件&lt;/li>
&lt;li>本地时区读取失败，使用 UTC 时间&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>问题就很显然了。&lt;br>
解决：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>opkg update
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>opkg install zoneinfo-asia
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;p>&lt;a href="https://stackoverflow.com/a/60161561/11571735">Writing and Compiling Program For OpenWrt&lt;/a>&lt;br>
&lt;a href="https://go.dev/doc/install/source#environment">Go environment&lt;/a>&lt;br>
&lt;a href="https://www.imhanjm.com/2017/10/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3golang%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86(time.time)/">深入理解GO时间处理(time.Time)&lt;/a>&lt;/p>
- https://ngtrio.com/posts/openwrt%E8%B7%91go%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/ - ngtrio. 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>Capnproto</title><link>https://ngtrio.com/posts/capnproto/</link><pubDate>Sun, 14 Nov 2021 16:52:38 +0800</pubDate><guid>https://ngtrio.com/posts/capnproto/</guid><description>星河鹭起 https://ngtrio.com/posts/capnproto/ -&lt;p>从Kitex的Rodemap中看到这一条：&lt;/p>
&lt;p>&lt;img src="images/image-20211115000303622.png" alt="image-20211115000303622">&lt;/p>
&lt;h3 id="简介">简介&lt;/h3>
&lt;p>&lt;a href="https://capnproto.org/index.html">Cap&amp;rsquo;n Proto &lt;/a>是Protocol Buffer 2 的主要作者 Kenton Varda 经过多年的实践经验和听取用户使用建议后所设计出来的数据交换格式(interchange format) 和 RPC 系统。&lt;/p>
&lt;h3 id="特性">特性&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>增量读：&lt;/strong> Cap’n Proto 的 message 不用等全部接收完成了才开始处理。因为消息中的 inner 对象是被安排在 outer 对象的后面的，而不像其他大多协议一样是嵌套关系。&lt;/li>
&lt;li>&lt;strong>随机访问：&lt;/strong> 能够只读一条消息中的一个 field，而不用解析整个消息。&lt;/li>
&lt;li>&lt;strong>mmap：&lt;/strong> 支持mmp。像 protobuf 就不支持，读很小一部分信息也会加载所有数据到用户态。（其实也没啥可比性，这个特性主要还是因为没有encoding/decoding过程）&lt;/li>
&lt;li>&lt;strong>高效的进程间通信：&lt;/strong> 同机器上的多个进程可以通过共享内存来分享Cap&amp;rsquo;n Message。没有必要将数据在user/kernel之间来回拷贝。&lt;/li>
&lt;li>&lt;strong>内存集中分配：&lt;/strong> Cap’n Proto 的对象通常会集中分配，有点类似池化，达到可复用的效果，缓存友好。&lt;/li>
&lt;li>&lt;strong>生成的代码量小：&lt;/strong> Protobuf 会为每种消息类型生成解析和编码的代码,代码量巨大. Cap’n Proto 生成的代码少至少一个数量级。&lt;/li>
&lt;li>&lt;strong>Time-traveling RPC：&lt;/strong> 下面介绍。&lt;/li>
&lt;/ul>
&lt;h3 id="rpc-protocol">RPC Protocol&lt;/h3>
&lt;p>&lt;a href="https://capnproto.org/rpc.html">Time travel&lt;/a>&lt;/p>
- https://ngtrio.com/posts/capnproto/ - ngtrio. 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>Go Array&amp;Slice</title><link>https://ngtrio.com/posts/go-array-slice/</link><pubDate>Tue, 05 Oct 2021 16:14:16 +0800</pubDate><guid>https://ngtrio.com/posts/go-array-slice/</guid><description>星河鹭起 https://ngtrio.com/posts/go-array-slice/ -&lt;h2 id="spec">Spec&lt;/h2>
&lt;blockquote>
&lt;p>Array:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-txt" data-lang="txt">&lt;span style="display:flex;">&lt;span>ArrayType = &amp;#34;[&amp;#34; ArrayLength &amp;#34;]&amp;#34; ElementType .
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ArrayLength = Expression .
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ElementType = Type .
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中ArrayLength是Array类型的一个组成部分，且必须能够计算为一个非负int类型可“常量表示（&lt;a href="https://golang.org/ref/spec#Constants">constant&lt;/a> &lt;a href="https://golang.org/ref/spec#Representability">representable&lt;/a>）”的值&lt;/p>
&lt;p>Slice:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-txt" data-lang="txt">&lt;span style="display:flex;">&lt;span>SliceType = &amp;#34;[&amp;#34; &amp;#34;]&amp;#34; ElementType .
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>一个Slice只要经过了初始化，就必将和一个底层的Array绑定，绑定在同一个Array上的Slices会共享内存&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过make初始化一个Slice的同时会初始化一个隐式的Array，也就是说下面两行代码是等价的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#658b00">make&lt;/span>([]&lt;span style="color:#00688b;font-weight:bold">int&lt;/span>, &lt;span style="color:#b452cd">50&lt;/span>, &lt;span style="color:#b452cd">100&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#658b00">new&lt;/span>([&lt;span style="color:#b452cd">100&lt;/span>]&lt;span style="color:#00688b;font-weight:bold">int&lt;/span>)[&lt;span style="color:#b452cd">0&lt;/span>:&lt;span style="color:#b452cd">50&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="arrays">Arrays&lt;/h2>
&lt;p>Golang的数组类型和C不同：&lt;/p>
&lt;ol>
&lt;li>Golang的数组是值，而不像C是数组头指针&lt;/li>
&lt;li>所以，在给一个函数传数组参树的时候，实际上是传的整个数组的一份copy&lt;/li>
&lt;li>数组长度是类型的一部分，所以&lt;code>[10]int&lt;/code>和&lt;code>[20]int&lt;/code>是两个不同的类型&lt;/li>
&lt;/ol>
&lt;h2 id="slices">Slices&lt;/h2>
&lt;p>内部表示为一个三元素结构体：&lt;/p>
&lt;ol>
&lt;li>ptr：指向底层数组的指针&lt;/li>
&lt;li>len：Slice长度，表示引用的元素个数&lt;/li>
&lt;li>cap：Slice容量，从Slice引用的第一个元素到底层数组最后一个元素的数量&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="images/slice-struct.png" alt="img">&lt;/p>
&lt;p>比如&lt;code>s := make([]int, 5)&lt;/code>，s的表示如下：&lt;/p>
&lt;p>&lt;img src="images/slice-1.png" alt="img">&lt;/p>
&lt;p>对s进行切片&lt;code>s = s[2:4]&lt;/code>，s的表示变为下面这样：&lt;/p>
&lt;p>&lt;img src="images/slice-2.png" alt="img">&lt;/p>
&lt;p>我们可以在cap范围内进行Slice的扩张，比如：&lt;code>s = s[:cap(s)]&lt;/code>，s的表示变为下面这样：&lt;/p>
&lt;p>&lt;img src="images/slice-3.png" alt="img">&lt;/p>
&lt;p>超过cap以及访问底层数组中处于Slice更前的元素都是&lt;strong>不被允许的&lt;/strong>&lt;/p>
&lt;h4 id="扩容">&lt;strong>扩容&lt;/strong>&lt;/h4>
&lt;p>当向Slice中添加元素的时候发现底层Array的容量已经不够则会触发扩容，底层Array将发生内存重分配。为了减少内存分配操作，我们应该在初始化Slice的时候尽量给出一个预期的cap大小。&lt;/p>
&lt;p>扩容逻辑类似与下面这段代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">func&lt;/span> &lt;span style="color:#008b45">Append&lt;/span>(slice, data []&lt;span style="color:#00688b;font-weight:bold">byte&lt;/span>) []&lt;span style="color:#00688b;font-weight:bold">byte&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> l := &lt;span style="color:#658b00">len&lt;/span>(slice)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">if&lt;/span> l + &lt;span style="color:#658b00">len&lt;/span>(data) &amp;gt; &lt;span style="color:#658b00">cap&lt;/span>(slice) { &lt;span style="color:#228b22">// reallocate&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#228b22">// Allocate double what&amp;#39;s needed, for future growth.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#d6d6c6">&lt;span> newSlice := &lt;span style="color:#658b00">make&lt;/span>([]&lt;span style="color:#00688b;font-weight:bold">byte&lt;/span>, (l+&lt;span style="color:#658b00">len&lt;/span>(data))*&lt;span style="color:#b452cd">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#228b22">// The copy function is predeclared and works for any slice type.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#658b00">copy&lt;/span>(newSlice, slice)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> slice = newSlice
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> slice = slice[&lt;span style="color:#b452cd">0&lt;/span>:l+&lt;span style="color:#658b00">len&lt;/span>(data)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#658b00">copy&lt;/span>(slice[l:], data)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">return&lt;/span> slice
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们必须将扩容后的Slice返回，因为Slice本身实际上还是值传递（底层字段ptr，len， cap）&lt;/p>
&lt;h4 id="潜在的陷阱">&lt;strong>潜在的陷阱&lt;/strong>&lt;/h4>
&lt;p>由于Array只有在不被任何地方引用的时候才能够被GC掉，而Slice会隐式地引用一个底层Array，那么会出现下面这种情况：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">var&lt;/span> digitRegexp = regexp.&lt;span style="color:#008b45">MustCompile&lt;/span>(&lt;span style="color:#cd5555">&amp;#34;[0-9]+&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">func&lt;/span> &lt;span style="color:#008b45">FindDigits&lt;/span>(filename &lt;span style="color:#00688b;font-weight:bold">string&lt;/span>) []&lt;span style="color:#00688b;font-weight:bold">byte&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> b, _ := ioutil.&lt;span style="color:#008b45">ReadFile&lt;/span>(filename)
&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#d6d6c6">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">return&lt;/span> digitRegexp.&lt;span style="color:#008b45">Find&lt;/span>(b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>b是一个包含了整个文件内容的Slice&lt;/p>
&lt;/li>
&lt;li>
&lt;p>返回值是包含了文件内容中第一组连续数字的Slice&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这两个Slice都引用着存储着所有文件内容的底层Array&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>当该函数被Caller调用后，实际上真正有用的数据就是返回值Slice所引用的数据。它的底层Array有大量不需要的数据得不到GC。&lt;/p>
&lt;p>为了避免这个问题，我们可以将我们需要的数据copy到一个新的Slice中再返回：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">func&lt;/span> &lt;span style="color:#008b45">CopyDigits&lt;/span>(filename &lt;span style="color:#00688b;font-weight:bold">string&lt;/span>) []&lt;span style="color:#00688b;font-weight:bold">byte&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> b, _ := ioutil.&lt;span style="color:#008b45">ReadFile&lt;/span>(filename)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> b = digitRegexp.&lt;span style="color:#008b45">Find&lt;/span>(b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c := &lt;span style="color:#658b00">make&lt;/span>([]&lt;span style="color:#00688b;font-weight:bold">byte&lt;/span>, &lt;span style="color:#658b00">len&lt;/span>(b))
&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#d6d6c6">&lt;span> &lt;span style="color:#658b00">copy&lt;/span>(c, b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">return&lt;/span> c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>本文图片引自：&lt;/p>
&lt;p>&lt;a href="https://go.dev/blog/slices-intro">https://go.dev/blog/slices-intro&lt;/a>&lt;/p>
&lt;/blockquote>
- https://ngtrio.com/posts/go-array-slice/ - ngtrio. 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>通过Github Action部署hexo博客到pages</title><link>https://ngtrio.com/posts/hexo-with-github-action/</link><pubDate>Mon, 04 Oct 2021 14:41:24 +0800</pubDate><guid>https://ngtrio.com/posts/hexo-with-github-action/</guid><description>星河鹭起 https://ngtrio.com/posts/hexo-with-github-action/ -&lt;p>Hexo部署到 Github Page 的一般分为下面三步&lt;/p>
&lt;ol>
&lt;li>写 Markdown&lt;/li>
&lt;li>将 Markdown 渲染成 HTML 静态页面&lt;/li>
&lt;li>将渲染得到的文件提交到 &lt;code>&amp;lt;username&amp;gt;.github.io&lt;/code> 仓库&lt;/li>
&lt;/ol>
&lt;p>如果以写博客为目的话，上述2，3两步其实是“写博客“之外的操作，比较影响写博客的沉浸式体验。这里可以引入现成的 Github Action ，将上述的 workflow 进行自动化。&lt;/p>
&lt;h2 id="准备">准备&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>Github Pages 仓库 &lt;code>&amp;lt;username&amp;gt;.github.io&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Blog 的源代码仓库&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ssh-keygen 生成一对非对称密钥，公钥作为 page 仓库的 &lt;code>Deploy Key&lt;/code>，私钥填入源代码仓库的 Secrets，供后续 Github Action 提交代码到 page 仓库&lt;/p>
&lt;/li>
&lt;li>
&lt;p>安装 hexo git 部署插件 hexo-deployer-git&lt;/p>
&lt;pre tabindex="0">&lt;code>npm install hexo-deployer-git --save
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;h2 id="配置hexo-deploy">配置Hexo Deploy&lt;/h2>
&lt;p>在hexo源码工程下的 &lt;code>_config.yml&lt;/code> 中配置下列信息&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">deploy&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>git&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">repo&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>git@github.com:username/&amp;lt;username&amp;gt;.github.io.git&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">branch&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>分支名&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#d6d6c6">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">message&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>提交信息&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在执行 &lt;code>hexo deploy&lt;/code> 命令时，hexo-deployer-git 插件大致会执行如下流程：&lt;/p>
&lt;ol>
&lt;li>将源代码仓库渲染成静态网页到 &lt;code>.deploy_git&lt;/code> 目录下&lt;/li>
&lt;li>然后将 &lt;code>.deploy_git&lt;/code> 目录 force push 到配置中指定的 repo 下的 branch 上，同时 git 提交信息就是配置中指定的 message&lt;/li>
&lt;/ol>
&lt;p>更多信息：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://hexo.io/docs/one-command-deployment">hexo部署&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git插件&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="编写github-action-workflow">编写Github Action Workflow&lt;/h2>
&lt;p>整个 workflow 拆分成下面几步：&lt;/p>
&lt;ol>
&lt;li>checkout 到源码主分支&lt;/li>
&lt;li>配置 node 环境&lt;/li>
&lt;li>配置 git 环境&lt;/li>
&lt;li>deploy hexo 带page仓库&lt;/li>
&lt;/ol>
&lt;p>workflow文件如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>auto deploy&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">on&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">push&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#d6d6c6">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">branches&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>- main&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">workflow_dispatch&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">jobs&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">build&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">runs-on&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>ubuntu-latest&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">steps&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>Checkout to main&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">with&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">submodules&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>recursive&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">fetch-depth&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b452cd">0&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">uses&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>actions/checkout@v2&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>Setup Node&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">uses&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>actions/setup-node@v1&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">with&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">node-version&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#cd5555">&amp;#39;14&amp;#39;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>Setup Git&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">env&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">DEPLOY_SECRET&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>${{ secrets.DEPLOY_SECRET }}&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">run&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>|&lt;span style="color:#cd5555">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> mkdir -p ~/.ssh
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> echo &amp;#34;$DEPLOY_SECRET&amp;#34; &amp;gt; ~/.ssh/id_rsa
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> chmod 400 ~/.ssh/id_rsa
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> ssh-keyscan github.com &amp;gt;&amp;gt; ~/.ssh/known_hosts
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> git config --global user.email &amp;#34;ngtercet@protonmail.com&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> git config --global user.name &amp;#34;Jaron&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>Deploy&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">run&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>|&lt;span style="color:#cd5555">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> chmod +x deploy.sh
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> ./deploy.sh&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>deploy 脚本如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#1e889b">#!/usr/bin/env bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#1e889b">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22"># install dependencies&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>npm install hexo-cli -g
&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#d6d6c6">&lt;span>npm install
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22"># fetch mtime from git log&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git ls-files -z source/_posts |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">while&lt;/span> &lt;span style="color:#658b00">read&lt;/span> -d &lt;span style="color:#cd5555">&amp;#39;&amp;#39;&lt;/span> path; &lt;span style="color:#8b008b;font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">if&lt;/span> [[ &lt;span style="color:#00688b">$path&lt;/span> == *.md ]]; &lt;span style="color:#8b008b;font-weight:bold">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">mtime&lt;/span>=&lt;span style="color:#8b008b;font-weight:bold">$(&lt;/span>git log -1 --format=&lt;span style="color:#cd5555">&amp;#34;@%ct&amp;#34;&lt;/span> &lt;span style="color:#00688b">$path&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> touch -d &lt;span style="color:#00688b">$mtime&lt;/span> &lt;span style="color:#00688b">$path&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#658b00">echo&lt;/span> &lt;span style="color:#cd5555">&amp;#34;change &lt;/span>&lt;span style="color:#00688b">$path&lt;/span>&lt;span style="color:#cd5555"> mtime to &lt;/span>&lt;span style="color:#00688b">$mtime&lt;/span>&lt;span style="color:#cd5555">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22"># hexo deploy&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hexo clean
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hexo deploy
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="踩坑点">踩坑点&lt;/h2>
&lt;h4 id="post-的更新时间不对">Post 的“更新时间”不对&lt;/h4>
&lt;h5 id="问题">问题&lt;/h5>
&lt;p>最初 Github Action 跑起来后发现博客里所有 Post 的”上次更新时间（updated属性）“都被刷新成部署的时间点了。&lt;/p>
&lt;p>翻了下 Hexo 相关文档发现，Post 的 updated 属性在缺省的情况下默认是 fallback 成 mtime，也就是文件的 &lt;code>Modified time&lt;/code>。&lt;/p>
&lt;p>在 action 每次跑的时候，其实都是在构建机器先 clone 了一份源码库，所有代码文件对于构建机器来说都是新创建的文件。&lt;/p>
&lt;p>而 linux 下新创建文件的 &lt;code>Modified time&lt;/code> 就是被初始化为创建时间的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>➜ ~ date &amp;amp;&amp;amp; touch &lt;span style="color:#658b00">test&lt;/span> &amp;amp;&amp;amp; stat &lt;span style="color:#658b00">test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Mon Oct &lt;span style="color:#b452cd">4&lt;/span> 03:36:08 PM CST &lt;span style="color:#b452cd">2021&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> File: &lt;span style="color:#658b00">test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Size: &lt;span style="color:#b452cd">0&lt;/span> Blocks: &lt;span style="color:#b452cd">0&lt;/span> IO Block: &lt;span style="color:#b452cd">4096&lt;/span> regular empty file
&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#d6d6c6">&lt;span>Device: 8,7 Inode: &lt;span style="color:#b452cd">135137&lt;/span> Links: &lt;span style="color:#b452cd">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Access: (0644/-rw-r--r--) Uid: ( 1000/ jaron) Gid: ( 1000/ jaron)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Access: 2021-10-04 15:36:08.763454559 +0800
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Modify: 2021-10-04 15:36:08.763454559 +0800
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Change: 2021-10-04 15:36:08.763454559 +0800
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Birth: 2021-10-04 15:36:08.763454559 +0800
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所以上述问题也就不言而喻了。&lt;/p>
&lt;h5 id="解决">解决&lt;/h5>
&lt;ol>
&lt;li>
&lt;p>Hexo文档的做法&lt;/p>
&lt;p>其实 Hexo 文档对这个问题也有相关描述，其中说的是 git 工作流下可以将 updated 属性 fallback 成 date，即文件创建时间。这种方式基本相当于因噎废食，直接将 updated 属性本身的语义给屏蔽了。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>updated_option&lt;/strong>&lt;/p>
&lt;p>&lt;code>updated_option&lt;/code> 控制了当 Front Matter 中没有指定 &lt;code>updated&lt;/code> 时，&lt;code>updated&lt;/code> 如何取值：&lt;/p>
&lt;ul>
&lt;li>&lt;code>mtime&lt;/code>: 使用文件的最后修改时间。这是从 Hexo 3.0.0 开始的默认行为。&lt;/li>
&lt;li>&lt;code>date&lt;/code>: 使用 &lt;code>date&lt;/code> 作为 &lt;code>updated&lt;/code> 的值。可被用于 Git 工作流之中，因为使用 Git 管理站点时，文件的最后修改日期常常会发生改变&lt;/li>
&lt;li>&lt;code>empty&lt;/code>: 直接删除 &lt;code>updated&lt;/code>。使用这一选项可能会导致大部分主题和插件无法正常工作。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>根据 git log 获取 post 的 last commit time&lt;/p>
&lt;p>在 workflow 中添加一步：将 post 文件上次 git commit 的时间，设置成该文件在 Github Action 构建机器下的mtime。&lt;/p>
&lt;p>那么Hexo在渲染的时候就会将 post 的上次更新时间设置为该 post 上次 git commit 的时间了（我们将每一次 post 文件的 git commit 都视作发/更新 post）。&lt;/p>
&lt;p>这部分工作实际已经包含于上文的 deploy 脚本中，这里单独拎出来：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22"># fetch mtime from git log&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git ls-files -z source/_posts |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">while&lt;/span> &lt;span style="color:#658b00">read&lt;/span> -d &lt;span style="color:#cd5555">&amp;#39;&amp;#39;&lt;/span> path; &lt;span style="color:#8b008b;font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">if&lt;/span> [[ &lt;span style="color:#00688b">$path&lt;/span> == *.md ]]; &lt;span style="color:#8b008b;font-weight:bold">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#d6d6c6">&lt;span> &lt;span style="color:#00688b">mtime&lt;/span>=&lt;span style="color:#8b008b;font-weight:bold">$(&lt;/span>git log -1 --format=&lt;span style="color:#cd5555">&amp;#34;@%ct&amp;#34;&lt;/span> &lt;span style="color:#00688b">$path&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> touch -d &lt;span style="color:#00688b">$mtime&lt;/span> &lt;span style="color:#00688b">$path&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#658b00">echo&lt;/span> &lt;span style="color:#cd5555">&amp;#34;change &lt;/span>&lt;span style="color:#00688b">$path&lt;/span>&lt;span style="color:#cd5555"> mtime to &lt;/span>&lt;span style="color:#00688b">$mtime&lt;/span>&lt;span style="color:#cd5555">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>注意：&lt;/strong>&lt;/p>
&lt;p>checkout action 默认是 shallow clone，但我们需要拉取全量 git log 才能读到正确的 last commit time，所以进行如下配置：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>Checkout to main&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">with&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">submodules&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>recursive&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#228b22"># 拉取全量 log&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#d6d6c6">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">fetch-depth&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b452cd">0&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">uses&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>actions/checkout@v2&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>checkout action 的更多信息：&lt;/p>
&lt;p>&lt;a href="https://github.com/actions/checkout">https://github.com/actions/checkout&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
- https://ngtrio.com/posts/hexo-with-github-action/ - ngtrio. 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>读DDIA-数据复制</title><link>https://ngtrio.com/posts/ddia/</link><pubDate>Sat, 02 Oct 2021 11:29:06 +0800</pubDate><guid>https://ngtrio.com/posts/ddia/</guid><description>星河鹭起 https://ngtrio.com/posts/ddia/ -&lt;h2 id="数据复制">数据复制&lt;/h2>
&lt;p>分布式系统中， 通过数据复制，我们希望达到下列目的：&lt;/p>
&lt;ul>
&lt;li>在全球各地数据中心间进行数据复制，使得数据在地理上更加接近用户，降低用户请求延迟&lt;/li>
&lt;li>提高可用性，当一个节点出现故障，我们有经过数据复制得到的副本继续工作&lt;/li>
&lt;li>横向扩展，用多个数据一致的节点提供同一个服务，提高吞吐量&lt;/li>
&lt;/ul>
&lt;p>目前业界有下面几种数据复制方案：&lt;/p>
&lt;ol>
&lt;li>主从复制&lt;/li>
&lt;li>多主节点复制&lt;/li>
&lt;li>无主节点复制&lt;/li>
&lt;/ol>
&lt;h3 id="主从复制">主从复制&lt;/h3>
&lt;p>原理简述：&lt;/p>
&lt;ol>
&lt;li>指定一个节点为主节点，其他都为从节点，客户端写数据库请求全部路由到主节点，由主节点首先将数据写入本地&lt;/li>
&lt;li>主节点数据本地写入完成后，将数据更改日志或者更改流发送给所有的从节点，从节点将数据写入本地，同时严格保持与主节点相同的写入数据&lt;/li>
&lt;li>客户端读数据请求可以路由到全部节点&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>注意：从节点只接受读数据请求，写请求由主节点负责&lt;/strong>&lt;/p>
&lt;p>&lt;img src="images/ddia-1.png" alt="">&lt;/p>
&lt;p>图1. 基于领导者(主-从)的复制&lt;/p>
&lt;p>&lt;strong>同步复制 or 异步复制&lt;/strong>&lt;/p>
&lt;p>&lt;img src="images/ddia-2.png" alt="">&lt;/p>
&lt;p>图2. Follower 1同步复制节点，Follower 2异步复制节点&lt;/p>
&lt;ul>
&lt;li>
&lt;p>同步复制&lt;/p>
&lt;p>用户的一次数据写请求在所有同步复制的从节点被写入后才会得到响应。&lt;/p>
&lt;ul>
&lt;li>优点：始终保证主从节点中的数据一致性&lt;/li>
&lt;li>缺点：只要有任何同步复制节点性能降低甚至故障，用户请求响应时间将大幅增加&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>异步复制&lt;/p>
&lt;p>用户的一次数据写请求在主节点写入后就会得到响应，主从复制将在后续异步进行&lt;/p>
&lt;ul>
&lt;li>优点：即使从节点出现数据复制滞后，主节点依旧能够响应写请求，吞吐量得到保证&lt;/li>
&lt;li>缺点：万一主节点主线故障下线，数据可能还没来得及复制完毕，导致新上线的主节点（从节点继承）数据丢失&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>半同步&lt;/p>
&lt;p>在业界实践中，上述两种方案只选其一都太过极端，一般会结合两种复制方式使用：&lt;/p>
&lt;p>一般存在一个从节点是同步复制，其他从节点是异步复制，万一同步节点不可用，将提升另一个异步节点作为同步节点，这样就保证了一个集群中至少拥有两个数据一致且最新的节点&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>新增节点&lt;/strong>&lt;/p>
&lt;p>场景：提高容错能力，替换故障节点等&lt;/p>
&lt;p>原理简述：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>在某个时间点对主节点生成数据快照&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将此快照应用到新增节点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>新增节点连接至主节点，请求快照点（与某个日志顺序点关联）后的数据更改日志&lt;/p>
&lt;p>PostgreSQL将日志顺序点称为log sequence number，MySQL则称为binlog coordinates&lt;/p>
&lt;/li>
&lt;li>
&lt;p>获取数据更改日志后，依次应用日志中的数据变更，这一步称为&lt;strong>追赶&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>处理节点失效&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>从节点失效：追赶式恢复&lt;/p>
&lt;p>从节点崩溃下线后，又顺利重启，可以通过数据复制日志得知故障前处理的最后一笔事务，然后向主节点请求该事务后发生的所有数据变更日志，并应用到本地，从而&lt;strong>追赶主节点&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>主节点失效：节点切换&lt;/p>
&lt;p>原理简述：&lt;/p>
&lt;ol>
&lt;li>确认主节点失效。一般基于超时机制判断，节点间心跳包如果超过一段时间没有得到响应，则视为节点失效&lt;/li>
&lt;li>选举新的主节点。从节点之间选举（超过半数节点达到共识），目标是选举出与主节点数据差异最小的一个从节点提升为主节点。这里涉及到共识算法，常见的有Raft等&lt;/li>
&lt;li>重新配置系统激活主节点。主要就是客户端的数据写请求现在应该路由到新晋升的主节点。前主节点重新上线后还要确保其降级为从节点，并认可新的主节点&lt;/li>
&lt;/ol>
&lt;p>存在的问题：&lt;/p>
&lt;ol>
&lt;li>前主节点重新上线后，可能依旧认为自己是主节点，从而会继续尝试同步其他节点，导致新主节点产生写冲突&lt;/li>
&lt;li>如果数据库需要和其他系统相协调，那么丢弃写入内容是极其危险的操作。比如说一个MySQL集群采用自增作为主键，如果一个数据未完全同步的MySQL从节点晋升为主节点，那么在后续插入行的操作下，新主节点将会重新分配旧主节点已经分配过的主键。倘若外部有一个redis引用了主键字段，就会发生MySQL与redis数据不一致的情况&lt;/li>
&lt;li>某些故障下，可能会发生多个节点认为自己是主节点，这种现象称为&lt;strong>脑裂（split brain）&lt;/strong>，这样就会导致多个节点可写，最后出现数据冲突的情况&lt;/li>
&lt;li>节点失效的超时检测机制很难设置一个合适的时间，时间越长代表总体恢复时间越长，时间越短，越可能导致不必要的节点切换&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>复制日志的实现&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>基于语句的复制&lt;/p>
&lt;p>主节点记录每次写请求所执行的语句，并将语句日志发送给从节点。对于关系数据库，每个INSERT、UPDATE或DELETE语句都会转发给从节点，然后交由从节点执行。&lt;/p>
&lt;p>有下列几个问题：&lt;/p>
&lt;ol>
&lt;li>任何非确定函数语句比如NOW()、RAND()，在不同节点上可能有不同返回值&lt;/li>
&lt;li>如果语句使用了自增等依赖现有数据的情况，会受到限制&lt;/li>
&lt;li>有副作用的语句，比如触发器、用户定义函数等，不同节点会产生不同的副作用&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>基于预写日志（WAL）传输&lt;/p>
&lt;p>Write-ahead logging，所有的修改在提交之前都要先写入log文件中，可以使用完全相同的日志文件复制一个内容和主节点完全相同的副本。&lt;/p>
&lt;p>有下列问题：&lt;/p>
&lt;p>日志记录的数据非常底层，WAL包含哪些磁盘块中的哪些字节发生了更改。这使复制与存储引擎紧密耦合。如果数据库将其存储格式从一个版本更改为另一个版本，通常不可能在主库和从库上运行不同版本的数据库软件。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>基于行的逻辑日志复制&lt;/p>
&lt;p>关系数据库的逻辑日志通常是以行的粒度描述对数据库表的写入的记录序列：&lt;/p>
&lt;ul>
&lt;li>对于插入的行，日志包含所有列的新值。&lt;/li>
&lt;li>对于删除的行，日志包含足够的信息来唯一标识已删除的行。通常是主键，但是如果表上没有主键，则需要记录所有列的旧值。&lt;/li>
&lt;li>对于更新的行，日志包含足够的信息来唯一标识更新的行，以及所有列的新值（或至少所有已更改的列的新值）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>基于触发器的复制&lt;/p>
&lt;p>触发器支持注册自己的应用层代码，可以将数据更改记录记录到一个单独的表中，然后在应用层访问该表，并执行自定义逻辑，比如将数据复制到另一个系统&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>复制滞后问题&lt;/strong>&lt;/p>
&lt;p>前面讨论过，实践中主从复制一般采用半同步方案，也就是存在一个同步节点和多个异步节点。而异步就意味着数据的非即时性。一个客户端同时查询主节点和一个异步从节点可能会得到不同的结果，这就是异步复制所带来的复制滞后问题。&lt;/p>
&lt;p>尽管如果主节点停止写入一段时间，从节点会通过追赶过程，最终会达到与主节点数据一致（最终一致性），但是当滞后时间过长，将会发生如下几个问题：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>读自己的写&lt;/p>
&lt;p>&lt;img src="images/ddia-3.png" alt="">&lt;/p>
&lt;p>用户在提交一些数据后再次读取提交的数据时，由于可能在一个数据尚未同步的从节点（Follower2）进行读取，会产生“数据似乎丢失”的假象。&lt;/p>
&lt;p>此时需要&lt;strong>read-after-write 一致性&lt;/strong>（写后读一致性、读写一致性）来防止这种现象。&lt;/p>
&lt;p>通常有以下几种方案：&lt;/p>
&lt;ol>
&lt;li>在主节点访问可能被用户自己修改的内容，否则就在从节点访问&lt;/li>
&lt;li>跟踪最近更新时间，设定一个阈值m，用户更新后m分钟内，查询请求都将由主节点处理，否则在从节点处理；同时监控从节点，避免从复制滞后超过m分钟的节从节点读取。&lt;/li>
&lt;li>客户端记录用户更新时间戳，并附带在请求中，服务端找到拥有此时间戳数据的节点后，就由此节点处理请求&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>单调读&lt;/p>
&lt;p>&lt;img src="images/ddia-4.png" alt="">&lt;/p>
&lt;p>如果用户从不同从库（一个新一个旧）进行多次读取，就可能发生这种情况&lt;/p>
&lt;p>&lt;strong>单调读一致性&lt;/strong>可以避免此异常，此种一致性比强一致性弱，比最终一致性强，实现单调读一致性的一种实现方式是，利用用户唯一标识符进行hash，从而将用户分配到一个固定的节点上。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>前缀一致读&lt;/p>
&lt;p>&lt;img src="images/ddia-5.png" alt="">&lt;/p>
&lt;p>如果某些分区的复制速度慢于其他分区，那么观察者在看到问题之前可能会看到答案。&lt;/p>
&lt;p>**前缀一致读（consistent prefix reads）**可以避免此种异常。&lt;/p>
&lt;p>这是分区（partitioned）（分片（sharded））数据库中的一个特殊问题，不同的分区独立运行，因此不存在全局写入顺序，一个解决方案是确保任何因果相关的写入都写入相同的分区，但是这就与分区的思想相违背了，在后续”Happens-before关系与并发小节“将介绍一个追踪事件因果关系的算法。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="多主节点复制">多主节点复制&lt;/h3>
&lt;p>每个主节点都可以接受写操作，并将写操作转发给其他节点。同时每个主节点扮演其他主节点的从节点。&lt;/p>
&lt;p>&lt;strong>处理写冲突&lt;/strong>&lt;/p>
&lt;p>&lt;img src="images/ddia-6.png" alt="">&lt;/p>
&lt;p>两个用户的写操作都成功了，但是在后续主节点间同步时出现了写冲突&lt;/p>
&lt;ul>
&lt;li>
&lt;p>避免冲突&lt;/p>
&lt;p>应用层保证写请求总是被路由到同一个主节点，局限性高&lt;/p>
&lt;/li>
&lt;li>
&lt;p>收敛于一致状态&lt;/p>
&lt;p>在主从复制模型下，写请求是符合顺序性原则的，但在多主节点模型下不存在这种顺序性，通常有下列几种方式来收敛于一致状态：&lt;/p>
&lt;ol>
&lt;li>给每个写入一个唯一的ID（例如，一个时间戳，一个长的随机数，一个UUID或者一个键和值的哈希），挑选最高ID的写入作为胜利者，并丢弃其他写入。如果使用时间戳，这种技术被称为最后写入胜利（LWW, last write wins）。虽然这种方法很流行，但是很容易造成数据丢失。&lt;/li>
&lt;li>为每个副本分配一个唯一的ID，ID编号更高的写入具有更高的优先级。这种方法也意味着数据丢失。&lt;/li>
&lt;li>以某种方式将这些值合并在一起 - 例如，按字母顺序排序，然后连接它们，在上图中，合并的标题可能类似于“B/C”）。&lt;/li>
&lt;li>用一种可保留所有信息的显式数据结构来记录冲突，并编写解决冲突的应用程序代码（也许通过提示用户的方式）。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>自定义冲突解决逻辑&lt;/p>
&lt;ol>
&lt;li>
&lt;p>在写入时执行&lt;/p>
&lt;p>只要数据库在复制变更日志时检测到了冲突，就调用应用层冲突处理程序&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在读取时执行&lt;/p>
&lt;p>所有冲突值都会被记录下来，下一次读取数据时，将这些冲突值都返回给应用层，交由应用层处理&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>拓扑结构&lt;/strong>&lt;/p>
&lt;p>&lt;img src="images/ddia-7.png" alt="">&lt;/p>
&lt;p>上图为多主节点模型的三种拓扑结构&lt;/p>
&lt;p>在环形拓扑（a）和星形拓扑（b）中，写请求都要经过多个节点的传递才能到达所有节点。并且每个请求都附带了已通过的节点标识符，依此来避免请求传递的无线循环。在这两个拓扑类型中，如果有节点发生了故障，将导致整个系统复制日志的转发受到影响。而全部-全部拓扑模型（c）中，请求可以通过多种不同路径转发，避免了单点故障，提高了容错性。&lt;/p>
&lt;p>这里有个请求到达顺序问题：&lt;/p>
&lt;p>&lt;img src="images/ddia-8.png" alt="">&lt;/p>
&lt;p>由于网络阻塞等原因，对于同一个主键的update操作先于insert操作到达了主节点2了，这里为了使得消息正确有序，可以使用&lt;strong>版本矢量&lt;/strong>技术，后文介绍。&lt;/p>
&lt;h3 id="无主节点复制">无主节点复制&lt;/h3>
&lt;p>无主节点复制方案中，客户端将写请求直接发送到多个副本，标杆：亚马逊Dynamo系统&lt;/p>
&lt;p>&lt;strong>节点失效时写入数据库&lt;/strong>&lt;/p>
&lt;p>在下图中&lt;/p>
&lt;ol>
&lt;li>一次写请求同时发送给了三个副本，其中副本三故障下线了，客户端收到两个节点的成功响应就认为写入成功&lt;/li>
&lt;li>故障节点重新上线后，为了避免读取到旧数据，客户端同样并发地向多个节点发送读请求&lt;/li>
&lt;li>客户端可能读到不同的结果，为了确定哪个是最新值，引入版本号技术&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="images/ddia-9.png" alt="">&lt;/p>
&lt;p>&lt;strong>读修复和反熵&lt;/strong>&lt;/p>
&lt;p>在上图最后，客户端将读取到的最新值有重新写回了落后副本，这个方案称为&lt;strong>读修复&lt;/strong>，主要适合频繁读取的场景。&lt;/p>
&lt;p>此外还有一种机制被经常应用于无主节点系统的&lt;strong>追赶&lt;/strong>过程，**反熵。**一些数据存储具有不断查找副本之间的数据差异的后台进程，并将任何缺少的数据从一个副本复制到另一个副本。与主从复制中的复制日志不同，此反熵过程不会以任何特定的顺序复制写入，并且在复制数据之前可能会有显著的延迟。&lt;/p>
&lt;p>&lt;strong>读写quorum&lt;/strong>&lt;/p>
&lt;p>假设有n个副本，写入需要w个节点确认，读取至少需要通过r个节点查询，那么n,w,r三者的关系应该是怎样的？可以很简单的得到&lt;code>n &amp;lt; w + r&lt;/code> ，只有这样读请求才能保证至少有一个结果是最新值。满足上述条件的w,r我们称之为**仲裁写，仲裁读。**通常，读取和写入操作总是并行地发送给全部n个节点，w和r只是决定需要返回结果的节点数。&lt;/p>
&lt;ul>
&lt;li>读多写少：可以设置w=n，r=1&lt;/li>
&lt;li>读少写多：可以设置w=1，r=n&lt;/li>
&lt;/ul>
&lt;p>当然上述两种方案都是最极端的设置，需要承担单点故障的风险，可以根据情况适当调整w，r值&lt;/p>
&lt;p>&lt;strong>quorum一致性的局限性&lt;/strong>&lt;/p>
&lt;p>一般情况下，设定w+r&amp;gt;n可以保证至少有一个最新值被读取到&lt;/p>
&lt;p>但是我们也可以设置w+r≤n，虽然读取请求最终可能返回一个旧值，但是这样的配置能够获得更低的延迟和更高的可用性，比较适合对数据实时性要求没那么高的场景&lt;/p>
&lt;p>需要注意的是，即使设定w+r&amp;gt;n， 也可能存在返回旧值的边界条件：&lt;/p>
&lt;ol>
&lt;li>如果采用了sloppy quorum（后面会讲），w个写入和r个读取可能落在完全不同的节点上，就无法保证读到最新值&lt;/li>
&lt;li>如果两个写入同时发生，不清楚哪一个先发生。在这种情况下，唯一安全的解决方案是合并并发写入（处理写入冲突）。如果根据时间戳（最后写入胜利）挑选出一个胜者，则由于时钟偏差写入可能会丢失。&lt;/li>
&lt;li>如果写操作与读操作同时发生，写操作可能仅反映在某些副本上。在这种情况下，不确定读取是返回旧值还是新值。&lt;/li>
&lt;li>如果写操作在某些副本上成功，而在其他节点上失败（例如，因为某些节点上的磁盘已满），且成功的数量小于w，所以系统判定写入失败，但是写入成功的副本并不会回滚写入的数据。这意味着尽管写入失败，后续的读取仍然可能会读取这次失败写入的值。&lt;/li>
&lt;li>如果具有新值的节点发生失效，恢复重启时，恢复数据来自旧值，则具有新值的副本数将小于w，打破了quorum条件&lt;/li>
&lt;li>即使一切工作正常，有时也会出现一些边界情况，书中第九章可线性化与quorum有介绍&lt;/li>
&lt;/ol>
&lt;p>这里依旧存在前文“复制滞后问题”中所列举出的一系列问题，如果确实需要更强的保证，就需要&lt;strong>事务&lt;/strong>与&lt;strong>共识&lt;/strong>的问题了。&lt;/p>
&lt;p>&lt;strong>宽松的quorum（sloppy quorum）与数据回传&lt;/strong>&lt;/p>
&lt;p>写和读仍然需要w和r成功的响应，但是可能包括不在指定的n个节点中的临时节点。&lt;/p>
&lt;p>详细点来说就是当客户端向指定的n个节点中写入时，无法得到w个节点的响应，那么系统允许将失败的那些写请求写入到临时节点，并且还是判定写成功。等到节点恢复后，临时节点就会将暂存的值写回到原始节点上，这个过程叫做&lt;strong>数据回传&lt;/strong>。&lt;/p>
&lt;p>由此可见，在宽松的quorum下，即使满足w+r&amp;gt;n，也不能保证能够一定读取到新值。但是它提高了很大的写入可用性。&lt;/p>
&lt;p>所有Dynamo风格的系统都已经支持了sloppy quorum。&lt;/p>
&lt;p>&lt;strong>检测并发写&lt;/strong>&lt;/p>
&lt;p>与多主节点复制类似（见前文【处理写冲突】），无主节点复制在并发对某个主键进行写时，也会出现写冲突，此外读修复和数据回传同样会导致并发写冲突。&lt;/p>
&lt;p>&lt;img src="images/ddia-10.png" alt="">&lt;/p>
&lt;ul>
&lt;li>节点 1 接收来自 A 的写入，但由于暂时中断，没接收到来自 B 的写入。&lt;/li>
&lt;li>节点 2 首先接收来自 A 的写入，然后接收来自 B 的写入。&lt;/li>
&lt;li>节点 3 首先接收来自 B 的写入，然后接收来自 A 写入。&lt;/li>
&lt;/ul>
&lt;p>如果像上面过程一样，每当接收到一个写入请求就简单的覆盖掉原来的值，那么整个系统将达不过到一致状态。&lt;/p>
&lt;p>在前文多主节点处理写冲突小节，有说到“收敛于一致性状态”，其中一个方案就是每个副本总是保存最新值。如果以客户端时间戳来定义最新，我们可以称其为：&lt;/p>
&lt;p>&lt;strong>最后写入者获胜（last write wins，LWW）&lt;/strong>&lt;/p>
&lt;p>LWW可以实现最终收敛，但是牺牲了一定的数据持久性，另外由于分布式系统中&lt;strong>不可靠时钟&lt;/strong>的挑战，LWW甚至会删除非并发写。&lt;/p>
&lt;p>对于缓存系统，数据持久性要求不高的场景LWW倒是挺适合的。&lt;/p>
&lt;p>&lt;strong>Happens-before关系和并发&lt;/strong>&lt;/p>
&lt;p>如果一个操作发生在另一个操作之前，则后面的操作可以覆盖之前的操作，属于因果关系。如果两个操作都不在另一个之前发生或者都不知道对方的发生，那么就属于并发关系，这就需要解决可能发生的写入冲突。&lt;/p>
&lt;p>&lt;strong>确定前后关系&lt;/strong>&lt;/p>
&lt;p>&lt;img src="images/ddia-11.png" alt="">&lt;/p>
&lt;ul>
&lt;li>服务器为每个键保留一个版本号，每次写入键时都增加版本号，并将新版本号与写入的值一起存储。&lt;/li>
&lt;li>当客户端读取键时，服务器将返回所有未覆盖的值以及最新的版本号。客户端在写入前必须先发送读取请求。&lt;/li>
&lt;li>客户端写入键时，必须包含之前读取的版本号，并且必须将之前读取的所有值合并在一起。来自写入请求的响应可以像读取一样，返回所有当前值。&lt;/li>
&lt;li>当服务器接收到具有特定版本号的写入时，它可以覆盖该版本号或更低版本的所有值（因为它知道它们已经被合并到新的值中），但是它必须保留更高版本号的值（因为这些值与当前的写操作属于并发）。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>版本矢量&lt;/strong>&lt;/p>
&lt;p>上述过程是只有一个副本的情况，在此副本服务端引入一个版本号技术就能够确定多个写请求是属于因果关系还是并发关系。&lt;/p>
&lt;p>如果扩展到无主节点集群，由于每个副本都能够接受写请求，那么单个的版本号就无法满足要求了，这就要求每个副本和每个主键都要维护一个版本号，并且同时还要跟踪其他副本的版本号，通过这些信息才能判断写请求的依赖关系。&lt;/p>
&lt;p>所有副本的版本号集合就被成为是&lt;strong>版本矢量。&lt;/strong>&lt;/p>
- https://ngtrio.com/posts/ddia/ - ngtrio. 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>Raft与ZAB对比</title><link>https://ngtrio.com/posts/raft%E4%B8%8Ezab%E5%AF%B9%E6%AF%94/</link><pubDate>Fri, 13 Aug 2021 08:29:23 +0800</pubDate><guid>https://ngtrio.com/posts/raft%E4%B8%8Ezab%E5%AF%B9%E6%AF%94/</guid><description>星河鹭起 https://ngtrio.com/posts/raft%E4%B8%8Ezab%E5%AF%B9%E6%AF%94/ -&lt;h2 id="zab">&lt;strong>ZAB&lt;/strong>&lt;/h2>
&lt;h3 id="zab节点状态">&lt;strong>ZAB节点状态：&lt;/strong>&lt;/h3>
&lt;ol>
&lt;li>LOOKING&lt;/li>
&lt;li>FOLLOWING&lt;/li>
&lt;li>LEADING&lt;/li>
&lt;li>OBSERVING&lt;/li>
&lt;/ol>
&lt;h3 id="专有名词">&lt;strong>专有名词&lt;/strong>&lt;/h3>
&lt;ol>
&lt;li>electionEpoch：选举的逻辑时钟&lt;/li>
&lt;li>peerEpoch：每次leader选举完成后会选出一个peerEpoch&lt;/li>
&lt;li>zxid：每个proposal的唯一id，高32位为peerEpoch低32位为counter&lt;/li>
&lt;li>lastProcessedZxid：最后一次commit的zxid&lt;/li>
&lt;/ol>
&lt;h3 id="理论实现的四个阶段">&lt;strong>理论实现的四个阶段&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>Phase 0. Leader election&lt;/strong>&lt;/p>
&lt;p>所有节点最开始都是LOOKING。只要有一个节点得到超半数节点的票数，它就可以当选准 leader。只有到达 Phase 3 准 leader 才会成为真正的 leader。这一阶段的目的是就是为了选出一个准 leader，然后进入下一个阶段。&lt;/p>
&lt;p>协议并没有规定详细的选举算法。&lt;/p>
&lt;p>&lt;strong>Phase 1. Discovery&lt;/strong>&lt;/p>
&lt;p>这个阶段有两个工作&lt;/p>
&lt;ol>
&lt;li>获取所有follower的lastZxid确定当前集群中有哪个节点拥有最新数据&lt;/li>
&lt;li>从所有follower的currentEpoch中选出一个最大的然后自增1得到peerEpoch，并发给所有follower，follower会将自己的acceptEpoch设置为peerEpoch，拒绝一切小于该epoch的请求&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>Phase 2. Synchronization&lt;/strong>&lt;/p>
&lt;p>这个阶段就是根据Discovery阶段找到的最新数据节点，leader会与其同步。&lt;/p>
&lt;p>&lt;strong>这里发生了follower到leader的数据同步，这是和zookeeper的实现还有raft的实现是不一样的&lt;/strong>&lt;/p>
&lt;p>同步完成后，会向所有follower同步数据，只有当quorum的follower都完成了数据同步后，其当选为新的leader。&lt;/p>
&lt;p>&lt;strong>Phase 3 . Broadcast&lt;/strong>&lt;/p>
&lt;p>到了这个阶段， leader才能对外提供服务，可以进行消息广播。数据同步的过程类似一个2PC，Leader将client发过来的请求生成一个事务proposal，然后发送给Follower，多数Follower应答之后，Leader再发送Commit给全部的Follower让其进行提交。&lt;/p>
&lt;h3 id="zookeeper的实现">&lt;strong>Zookeeper的实现&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>Phase 0. Fast Leader Election&lt;/strong>&lt;/p>
&lt;p>这个阶段相当于是理论实现中的Phase 0，Phase 1的整合。每个节点不断更新自己的票箱，最终能够找到lastZxid最大的节点，并将其推选为leader。&lt;/p>
&lt;p>这样的实现也避免了sync的时候需要从follower向leader同步数据。&lt;/p>
&lt;p>成为leader的条件&lt;/p>
&lt;ul>
&lt;li>epoch最大&lt;/li>
&lt;li>zxid最大&lt;/li>
&lt;li>server id最大&lt;/li>
&lt;/ul>
&lt;p>节点在选举开始都默认投票给自己，当接收其他节点的选票时，会根据上面的条件更改自己的选票并重新发送选票给其他节点，当有一个节点的得票超过半数，该节点会设置自己的状态为 leading，其他节点会设置自己的状态为 following。&lt;/p>
&lt;p>&lt;strong>Phase 1. Recovery&lt;/strong>&lt;/p>
&lt;p>这个阶段所有的follower都会发送自己的lastZxid到leader。&lt;/p>
&lt;p>Leader会根据follower的lastZxid和自己的lastZxid进行比较，做出如下三种可能的同步策略：&lt;/p>
&lt;ol>
&lt;li>SNAP：如果follower数据太老，已经小于minCommitLog则采取快照同步&lt;/li>
&lt;li>DIFF：如果follower的lastZxid 处于minCommitLog和maxCommitLog之间，则采取增量同步F.lastZxid-L.lastZxid之间的数据&lt;/li>
&lt;li>TRUNC：当F.lastZxid比L.lastZxid大时，Leader会让follower删除所有对于的数据&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>Phase 2. Broadcast&lt;/strong>&lt;/p>
&lt;p>同理论实现&lt;/p>
&lt;h2 id="raft">&lt;strong>Raft&lt;/strong>&lt;/h2>
&lt;h3 id="raft节点状态">&lt;strong>Raft节点状态：&lt;/strong>&lt;/h3>
&lt;ol>
&lt;li>FOLLOWER&lt;/li>
&lt;li>CANDIDATE&lt;/li>
&lt;li>LEADER&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>触发Leader选举时机&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>当整个集群初始化的时候，所有节点都是Follower，此时等到超时的节点会转变为Candidate发起RequestVoteRPC发起选举&lt;/li>
&lt;li>当leader down掉后，由于不再有AppendEntriesRPC来维持心跳，follower也会发生超时，开始选举&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>Leader Election&lt;/strong>&lt;/p>
&lt;p>当Follower/Candidate发生超时&lt;/p>
&lt;ol>
&lt;li>首先将自己的Term自增1&lt;/li>
&lt;li>然后投票给自己&lt;/li>
&lt;li>会向集群中的所有节点发送RequestVoteRPC&lt;/li>
&lt;/ol>
&lt;p>当收到majority的选票后，自己会转变为Leader，此时会开始向所有其他节点发送AppendEntriesRPC。&lt;/p>
&lt;p>Follower投票的条件：&lt;/p>
&lt;ol>
&lt;li>Candidate的Term比自身的Term大&lt;/li>
&lt;li>如果Term一样，那么就需要candidate的last log index比自己的大&lt;/li>
&lt;/ol>
&lt;p>通过上述条件选出来的leader能够保证会拥有所有已经提交的entry&lt;/p>
&lt;p>&lt;strong>Log Replication&lt;/strong>&lt;/p>
&lt;p>选举完成后：&lt;/p>
&lt;ol>
&lt;li>当一个节点成为leader后会初始化两个数组
&lt;ol>
&lt;li>nextIndex，记录所有follower的下一个日志index，初始值为leader的last log index&lt;/li>
&lt;li>matchIndex，记录所有follower已经确定完成同步的日志index&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>然后通过AppendEntriesRPC完成数据同步：
&lt;ol>
&lt;li>prevLogIndex：记录上一条日志index&lt;/li>
&lt;li>prevLogTerm：记录上一条日志Term&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>只要follower发现没有一个下标为prevLogIndex并且term为prevLogTerm的entry都会返回false，leader便会把其对应的nextIndex减一，一直重复这个过程直到两者match，并更新matchIndex&lt;/li>
&lt;li>后续AppendEntriesRPC便会逐渐将Follower的日志补齐&lt;/li>
&lt;/ol>
&lt;p>处理客户端命令：&lt;/p>
&lt;ol>
&lt;li>Leader处理读，每个entry只有append到大多数节点的时候，主节点才视为commit，并且更新commitIdex，随后这个commitIndex会被AppendEntriesRPC逐渐同步到Follower&lt;/li>
&lt;li>所有节点，只要发现commitIndex&amp;gt;lastApplied都会将entry提交到状态机&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>Log Compaction&lt;/strong>&lt;/p>
&lt;p>由于内存是有限的，所有的节点都会定期对缓存的log进行compact生成snapshot，对于远远落后的follower，主节点会发送InstallSnapshotRPC给follower,这个过程是分成一个个chunk来完成的&lt;/p>
&lt;h3 id="两者不同点">&lt;strong>两者不同点&lt;/strong>&lt;/h3>
&lt;ol>
&lt;li>触发选举方式不同
&lt;ul>
&lt;li>raft follower超时+prevote避免term无限递增&lt;/li>
&lt;li>zab follower超时+leader发现大多数follower超时&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>选举机制不同
&lt;ul>
&lt;li>raft每个term只会投一票，存在split vote可能性&lt;/li>
&lt;li>zab每个epoch会不断更新选票，时间理论上相对Raft要花费的多。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>日志同步机制不同，并且对未提交日志的处理方式不同
&lt;ul>
&lt;li>Raft中leader是根据AppendEntriesRPC的nextIndex，prevLogIndex，prevLogTerm来跟踪follower的同步情况，并实现逐步的同步，期间有个election restriction，限制term只能commit属于term的entry，旧term的entry只能被当前term的commit给附带commit。所以raft中未提交的日志可能提交也可能会被覆盖&lt;/li>
&lt;li>ZAB在选主后，有一个Recovery阶段，根据每个节点的lastZxid来判断日志的取舍，在leader上所有没有commit的日志都会提交。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>残留日志处理
&lt;ul>
&lt;li>Raft：对于之前term的过半或未过半复制的日志采取的是保守的策略，全部判定为未提交，只有当当前term的日志过半了，才会顺便将之前term的日志进行提交&lt;/li>
&lt;li>ZooKeeper：采取激进的策略，对于所有过半还是未过半的日志都判定为提交，都将其应用到状态机中&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
- https://ngtrio.com/posts/raft%E4%B8%8Ezab%E5%AF%B9%E6%AF%94/ - ngtrio. 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>Scala隐式转换的理解</title><link>https://ngtrio.com/posts/scala%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E7%9A%84%E7%90%86%E8%A7%A3/</link><pubDate>Fri, 09 Jul 2021 09:29:32 +0800</pubDate><guid>https://ngtrio.com/posts/scala%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E7%9A%84%E7%90%86%E8%A7%A3/</guid><description>星河鹭起 https://ngtrio.com/posts/scala%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E7%9A%84%E7%90%86%E8%A7%A3/ -&lt;h3 id="将隐式解析看作是方法调用">将隐式解析看作是方法调用&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>隐式参数&lt;/p>
&lt;p>ImplicitValue: Unit =&amp;gt; RequiredType&lt;/p>
&lt;/li>
&lt;li>
&lt;p>隐式转换&lt;/p>
&lt;p>ImplicitValue: GivenType =&amp;gt; RequiredType.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在方法没有被定义的类型上调用方法&lt;/p>
&lt;p>ImplicitValue: GivenType =&amp;gt; ???&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="隐式范围implicit-scope定义">隐式范围（implicit scope）定义&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>Current scope&lt;/p>
&lt;ul>
&lt;li>Local scope&lt;/li>
&lt;li>Current Scope defined by Imports (Explicit Imports and Wildcard Imports)&lt;/li>
&lt;/ul>
&lt;p>简单的说就是和变量、标识符等的搜索scope是一样的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Associated Type&lt;/p>
&lt;ul>
&lt;li>Function0[RequiredType]&lt;/li>
&lt;li>Function1[GivenType, RequireType]&lt;/li>
&lt;li>Function1[GivenType, ???]&lt;/li>
&lt;/ul>
&lt;p>隐式范围包括上述涉及到的类型的伴生对象，如果说上述类型是类型构造器，比如说RequiredType[T]，那么T的隐式范围同样会被搜索。GivenType, RequireType的父类/trait（如果有）的伴生对象同样也会被搜索。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.geekabyte.io/2017/12/implicit-scope-and-implicit-resolution.html">https://www.geekabyte.io/2017/12/implicit-scope-and-implicit-resolution.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
- https://ngtrio.com/posts/scala%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E7%9A%84%E7%90%86%E8%A7%A3/ - ngtrio. 本站遵循 CC-BY-NC 4.0 协议</description></item></channel></rss>